---
title: "Test"
date: 2021-08-02T21:23:23+08:00
draft: true
---

##  数仓--维度模型

###  维度建模基本概念

维度模型是数据仓库领域大师Ralph Kimall所倡导，他的《数据仓库工具箱》，是数据仓库工程领域最流行的数仓建模经典。维度建模以分析决策的需求出发构建模型，构建的数据模型为分析需求服务，因此它重点解决用户如何更快速完成分析需求，同时还有较好的大规模复杂查询的响应性能。

**维度建模是专门应用于分析型数据库 数据仓库 数据集市建模的方法。数据集市可以理解为是一种"小型数据仓库"。**

#### 事实表

发生在现实世界中的操作型事件，其所产生的可度量数值，存储在事实表中。从最低的粒度级别来看，事实表行对应一个度量事件，反之亦然。

事实表表示对分析主题的度量。比如一次购买行为我们就可以理解为是一个事实。

| 事实表                                                       |
| ------------------------------------------------------------ |
| ![image-20200109233909408](数仓相关概念.assets/image-20200109233909408.png) |



图中的订单表就是一个事实表，你可以理解他就是在现实中发生的一次操作型事件，我们每完成一个订单，就会在订单中增加一条记录。

**事实表的特征：表里没有存放实际的内容，他是一堆主键的集合，这些ID分别能对应到维度表中的一条记录。**事实表包含了与各维度表相关联的外键，可与维度表关联。事实表的度量通常是数值类型，且记录数会不断增加，表数据规模迅速增长。

####  维度表

每个维度表都包含单一的主键列。维度表的主键可以作为与之关联的任何事实表的外键，当然，维度表行的描述环境应与事实表行完全对应。**维度表通常比较宽，是扁平型非规范表，包含大量的低粒度的文本属性。**

**维度表示你要对数据进行分析时所用的一个量**,比如你要分析产品销售情况, 你可以选择按类别来进行分析,或按区域来分析。这样的按..分析就构成一个维度。上图中的用户表 商家表 时间表这些都属于维度表，这些表都有一个唯一的主键，然后在表中存放了详细的数据信息。

总的说来，在数据仓库中不需要严格遵守规范化设计原则。因为数据仓库的主导功能就是面向分析，以查询为主，不涉及数据更新操作。事实表的设计是以能够正确记录历史信息为准则，维度表的设计是以能够以合适的角度来聚合主题内容为准则。



###  维度建模三种模式

#### **星型模型**

**星形模式(Star Schema)是最常用的维度建模方式**。星型模式是以事实表为中心，所有的维度表直接连接在事实表上，像星星一样。

星形模式的维度建模由一个事实表和一组维表成，且具有以下特点：

 a. 维表只和事实表关联，维表之间没有关联；

 b. 每个维表主键为单列，且该主键放置在事实表中，作为两边连接的外键；

c. 以事实表为核心，维表围绕核心呈星形分布；

| 星型模型                                                     |
| ------------------------------------------------------------ |
| ![image-20200102223306910](数仓相关概念.assets/image-20200102223306910.png) |

 





#### 雪花模式

**雪花模式(Snowflake Schema)是对星形模式的扩展**。雪花模式的维度表可以拥有其他维度表的，虽然这种模型相比星型更规范一些，但是由于这种模型不太容易理解，维护成本比较高，而且性能方面需要关联多层维表，性能也比星型模型要低。所以一般不是很常用。

| 雪花模型                                                     |
| ------------------------------------------------------------ |
| ![image-20200102223324632](数仓相关概念.assets/image-20200102223324632.png) |

 





####  星座模式

**星座模式是星型模式延伸而来**，星型模式是基于一张事实表的，而星座模式是基于多张事实表的，而且共享维度信息。

前面介绍的两种维度建模方法都是多维表对应单事实表，但在很多时候维度空间内的事实表不止一个，而一个维表也可能被多个事实表用到。在业务发展后期，绝大部分维度建模都采用的是星座模式。

| 星座模型                                                     |
| ------------------------------------------------------------ |
| ![image-20200102223337629](数仓相关概念.assets/image-20200102223337629.png) |



## 数仓--分层

###  为什么要分层

分层的主要原因是在管理数据的时候，能对数据有一个更加清晰的掌控，详细来讲，主要有下面几个原因：

**清晰数据结构：**

每一个数据分层都有它的作用域，这样我们在使用表的时候能更方便地定位和理解。

**数据血缘追踪：**

 简单来说，我们最终给业务呈现的是一个能直接使用业务表，但是它的来源有很多，如果有一张来源表出问题了，我们希望能够快速准确地定位到问题，并清楚它的危害范围。

**减少重复开发：**

规范数据分层，开发一些通用的中间层数据，能够减少极大的重复计算。

**把复杂问题简单化(任务分解)：**

将一个复杂的任务分解成多个步骤来完成，每一层只处理单一的步骤，比较简单和容易理解。而且便于维护数据的准确性，当数据出现问题之后，可以不用修复所有的数据，只需要从有问题的步骤开始修复。

**屏蔽原始数据的异常:**

屏蔽业务的影响，不必改一次业务就需要重新接入数据



### 数仓分层

数据分层每个企业根据自己的业务需求可以分成不同的层次，但是最基础的分层思想，理论上数据分为三个层，数据运营层、 数据仓库层、和数据服务层。基于这个基础分层之上添加新的层次，来满足不同的业务需求。



![image-20200702140023201](数仓相关概念.assets/image-20200702140023201.png)

#### 0 Dimension（维表层）

1，高基数维度数据：一般是用户资料表，商品资料表类似的资料表。数据量可能是千万级或者上亿级别
2，低基数维度数据：一般是配置表，比如枚举值对应的中文含义，或者日期维表。数据量可能是个位数或者几千几万



#### 1 ODS （Operate data store，数据准备层）

Operate data store，操作数据存储，是最接近数据源中数据的一层，数据源中的数据，经过抽取 洗净 传输，也就说传说中的ETL之后，装入本层。本层的数据，总体上大多是按照源头业务系统的分类方式而分类的。

例如：MySQL里面的一张表可以通过sqoop之间抽取到ODS层

ODS层数据的来源方式：

* 业务库
  * 经常会使用sqoop来抽取，比如我们每天定时抽取一次。在实时方面，可以考虑用canal监听mysql的binlog，实时接入即可。

* 埋点日志 
  * 线上系统会打入各种日志，这些日志一般以文件的形式保存，我们可以选择用flume定时抽取，也可以用用spark streaming或者Flink来实时接入，当然，kafka也会是一个关键的角色。

* 消息队列
  * 来自ActiveMQ Kafka的数据等



功能

* ODS层是数据仓库准备区，为DWD层提供基础原始数据，可减少对业务系统的影响 

建模方式及原则：

* 从业务系统增量抽取 保留时间由业务需求决定 可分表进行周期存储 数据不做清洗转换与业务系统数据模型保持一致 按主题逻辑划分



#### 2 DW（Data warehouse，数据仓库层）

Data warehouse，数据仓库层。在这里，从ODS层中获得的数据按照主题建立各种数据模型。例如以研究人的旅游消费为主题的数据集中，便可以结合航空公司的登机出行信息，以及银联系统的刷卡记录，进行结合分析，产生数据集。在这里，我们需要了解四个概念：维（dimension） 事实（Fact） 指标（Index）和粒度（ Granularity）。

数据粒度：数据的详细程度

##### DWD/DWI （Data WareHouse Detail，数据明细层）

==实时宽表==

该层一般保持和ODS层一样的数据粒度，并且提供给一定的数据质量保证。同时为了提高数据明细层的易用性，该层会采用一些==维度退化手法==，==将维度退化到事实表中==，减少事实表和维度表的关联。另外，在该层也会做一部分的数据聚合，将相同主题的数据汇集到一张表中，提高数据的可用性



一般采用维度模型方法作为理论基础，==更多的采用一些维度退化手法==，将维度退化至事实表中，减少维度表与事实表的关联，提高明细数据表的易用性；同时在汇总数据层要加强指标的维度退化，采用更多的宽表化手段构建公共指标数据层，提升公共指标的复用性，减少重复加工

**例如：**
ODS层，表1：
	姓名，城市，年龄

ODS层，表2：
	姓名，订单，订单金额

DWD层，退化成宽表：
	姓名，城市，年龄，订单，订单金额

维度退化感觉就是把维度对应的描述直接放在事实表中，使用时不再关联维度表，把表做宽，查询更方便



功能：

* 为DW层提供来源明细数据，提供业务系统细节数据的长期沉淀，为未来分析类需求的扩展提供历史数据支撑 

建模方式及原则：

* 数据模型与ODS层一致，不做清洗转换处理 为支持数据重跑可额外增加数据业务日期字段 可按年月日进行分表 用增量ODS层数据和前一天DWD相关表进行merge处理





##### DWM/DWB（Data WareHouse Middle，数据中间层）

==分析中间表（基础指标、多维、多指标）==

在DWD层的数据基础上，对数据做轻度的聚合操作，生成一系列的中间表提升公共指标的复用性，减少重复加工，直观来说，就是对通用的核心维度进行聚合操作，算出相应的统计指标



在实际计算中，如果直接从DWD或者ODS计算宽表的统计指标，会存在计算量太大并且维度太少的问题。一般做法是。在==DWM层先计算出多个小的中间表==，再拼接成一张DWS的大宽表。由于宽和窄的界限不易界定，也可以去掉DWM这一层，只保留DWS层，将所有的数据放在DWS亦可



##### DWS（Data WareHouse Service，数据服务层）

==分析后的宽表（单维度、多指标）==

又称为数据集市或者宽表，按照业务划分，例如流量，订单，用户等，生成字段比较多的宽表，用于后续的业务查询，OLAP分析，数据分析等。



功能：

* 为DW 提供细粒度数据，细化成DWB和DWS；
* DWB是根据DWD明细数据进行转换，如维度转代理键 身份证清洗 会员注册来源清晰 字段合并 空值处理 脏数据处理 IP清晰转换 账号余额清洗 资金来源清洗等；
* DWS是根据DWB层数据按各个维度ID进行高粒度汇总聚合，如按交易来源，交易类型进行汇合

建模方式及原则：

* 聚合 汇总增加派生事实；
* 关联其它主题的事实表，DW层可能会跨主题域；
* DWB保持低粒度汇总加工数据，DWS保持高粒度汇总数据；
* 数据模型可能采用反范式设计，合并信息等。



#### 3 ADS/APP/DM（Application Data Store，数据应用层）

==前端展示的数据==

该层主要是提供数据产品和数据分析使用的数据，一般会存放在ES MySQL等系统中供线上系统使用，也可能会存在Hive或者Druid中供数据分析和数据挖掘使用。 

例如：我们经常说的报表数据，或者说那种大宽表，一般就放在这里。



主要提供给数据铲平和数据分析使用的数据，一般会放在ES，MYSQL，Redis等系统供线上系统使用，也可以放在Hive中供数据分析和数据挖掘使用



功能：

* 面向用户应用和分析需求，包括前端报表 分析图表 KPI 仪表盘 OLAP 专题等分析，面向最终结果用户；

* 适合作OLAP 报表模型，如ROLAP,MOLAP；

* 根据DW层经过聚合汇总统计后的粗粒度事实表

  建模方式及原则：

* 保持数据量小；

* 维度建模，星形模型；

* 各位维度代理键+度量；

* 增加数据业务日期字段，支持数据重跑；

* 不分表存储






### 分层举例

![image-20200702140938285](数仓相关概念.assets/image-20200702140938285.png)



## 数仓--表的种类

一般情况下表分为两个类型，分别维度表和事务表

####  维度表

维度表，一般是指对应一些业务状态，代码的解释表。也可以称之为码表。比如地区表，订单类型，支付方式，商品分类等等。

维度表可以分为两类：**固定维度表&一般维度表**

1.固定维度（不变）：表的数据是不变的

2.一般维度（变化）：表的数据是不断增加和变化的

####  事实表

事实表分为两类：**事务型事实表和周期型事实表**

1.事务型事实表（不变）：一般指随着业务发生不断产生的数据。特点是一旦发生不会再变化。 一般比如，交易流水，操作日志，出库入库记录等等。

2.周期型事实表（变化）：一般指随着业务发生不断产生的数据。与事务型不同的是，数据会随着业务周期性的推进而变化。
比如订单，其中订单状态会周期性变化。 再比如，请假 贷款申请，随着批复状态在周期性变化。



##  数仓--表的同步策略

####   维度表

可能会有变化的数据可以存储**每日全量**或者使用**拉链表**。（比如订单类型，审批状态，商品分类）

####  事实表

**事务型事实表**

* **每日增量**： 因为数据不会变化，而且数据量巨大，所以每天只同步新增数据即可；每日分区。

**周期型事实表**

* **每日全量**：首先这类表从数据量的角度，存每日全量的话，数据量太大，冗余也太大。
* **每日增量**：如果用每日增量的话无法反应数据变化；每日新增及变化量可以用，包括了当日的新增和修改。一般来说这个表，足够计算大部分当日数据的。但是这种依然无法解决能够得到某一个历史时间点（时间切片）的切片数据。
* **拉链表**：利用每日新增和变化表，制作一张拉链表，以方便的取到某个时间切片的快照数据。
  所以我们需要得到每日新增及变化量。



##  数仓--缓慢变化维

###  什么是缓慢变化维（SCD)

**1 缓慢变化维简介**

- 缓慢变化维，简称SCD（Slowly Changing Dimensions）
- 一些维度表的数据不是静态的，而是会随着时间而缓慢地变化（这里的缓慢是相对事实表而言，事实表数据变化的速度比维度表快）
- 这种随着时间发生变化的维度称之为缓慢变化维
- 把处理维度表数据历史变化的问题，称为缓慢变化维问题，简称SCD问题

**2 举例说明**

例如：用根据用户维度，统计不同出生年份的消费金额占比。（80后 90后 00后）。

而期间，用户可能去修改用户数据，例如：将出生日期改成了 1992年。此时，用户维度表就发生了变化。当然这个变化相对事实表的变换要慢。但这个用户维度表的变化，就是缓慢变化维。



| 用户ID | 用户名 | 出生日期   | 住址         |
| ------ | ------ | ---------- | ------------ |
| 114    | 张三   | 1988-09-08 | 北京市朝阳区 |

这个用户的数据不是一直不变，而是有可能发生变化。例如：用户修改了出生日期 或者用户修改了住址。

### SCD问题的几种解决方案

以下为解决缓慢变化维问题的几种办法：

- 保留原始值：指标计算不符合最新维度数据

- 改写属性值：无法获取到历史状态

- 增加维度新行：拉链表

- 增加维度新列：成本太高

- 添加历史表：增加维护难度

  对于历史数据会变化的以及还有新增数据的表同步到数仓中我们有两个要求：

  1、 数据的历史状态我们要保存，

  2、对于新增数据也保存

#### SCD解决方案 - 保留原始值

某一个属性值绝不会变化。事实表始终按照该原始值进行分组。例如：

- 出生日期的数据，始终按照用户第一次填写的数据为准

#### SCD解决方案 - 改写属性值

- 对其相应需要重写维度行中的旧值，以当前值替换。因此其始终反映最近的情况
- 当一个维度值的数据源发生变化，并且不需要在维度表中保留变化历史时，通常用新数据来覆盖旧数据。这样的处理使属性所反映的中是最新的赋值。

用户维度表

修改前：

| 用户ID | 用户名 | 出生日期   | 住址         |
| ------ | ------ | ---------- | ------------ |
| 114    | 张三   | 1988-09-08 | 北京市朝阳区 |

修改后：



| 用户ID | 用户名 | 出生日期       | 住址             |
| ------ | ------ | -------------- | ---------------- |
| 114    | 张三   | **1992-09-08** | **北京市海淀区** |

- 这种方法有个前提，用户不关心这个数据的变化
- 这样处理，易于实现，但是没有保留历史数据，无法分析历史变化信息

#### SCD解决方案 - 增加维度新行

数据仓库系统的目标之一是正确地表示历史。典型代表就是**拉链表**。

保留历史的数据，并插入新的数据。

用户维度表

修改前：

|      | 用户ID | 用户名 | 出生日期   | 住址         |
| ---- | ------ | ------ | ---------- | ------------ |
| 9527 | 114    | 张三   | 1988-09-08 | 北京市朝阳区 |

修改后：

| 编号 | 用户ID | 用户名 | 出生日期       | 住址             |
| ---- | ------ | ------ | -------------- | ---------------- |
| 9527 | 114    | 张三   | 1988-09-08     | 北京市朝阳区     |
| 9528 | 114    | 张三   | **1992-09-08** | **北京市海淀区** |

#### SCD解决方案 - 增加维度新列

用不同的字段来保存不同的值，就是在表中增加一个字段，这个字段用来保存变化后的当前值，而原来的值则被称为变化前的值。总的来说，这种方法通过添加字段来保存变化后的痕迹。

用户维度表

修改前：

| 编号 | 用户ID | 用户名 | 出生日期   | 住址         |
| ---- | ------ | ------ | ---------- | ------------ |
| 9527 | 114    | 张三   | 1988-09-08 | 北京市朝阳区 |

修改后

| 编号 | 用户ID | 用户名 | 出生日期   |                | 住址         | 现住址           |
| ---- | ------ | ------ | ---------- | -------------- | ------------ | ---------------- |
| 9527 | 114    | 张三   | 1988-09-08 | **1992-09-08** | 北京市朝阳区 | **北京市海淀区** |



#### SCD解决方案 - 使用历史表

另外建一个表来保存历史记录，这种方式就是将历史数据与当前数据完全分开来，在维度中只保存当前最新的数据。

用户维度表

| 编号 | 用户ID | 用户名 | 出生日期   | 住址         |
| ---- | ------ | ------ | ---------- | ------------ |
| 9527 | 114    | 张三   | 1992-09-08 | 北京市海淀区 |

用户维度历史表

| 编号 | 用户ID | 用户名 | 出生日期   | 住址         |
| ---- | ------ | ------ | ---------- | ------------ |
| 9537 | 114    | 张三   | 1988-09-02 | 北京市朝阳区 |
| 9527 | 114    | 张三   | 1992-09-08 | 北京市海淀区 |

这种方式的优点是可以同时分析当前及前一次变化的属性值，缺点是只保留了最后一次变化信息。

###  数据采集-拉链表技术介绍

数据仓库的数据模型设计过程中，经常会遇到这样的需求：

1. 表中的部分字段会被update，例如：
   * 用户的地址，产品的描述信息，品牌信息等等;
2. 需要查看某一个时间点或者时间段的历史快照信息，例如：
   - 查看某一个产品在历史某一时间点的状态
   - 查看某一个用户在过去某一段时间内，更新过几次等等
3. 变化的比例和频率不是很大，例如：
   - 总共有1000万的会员，每天新增和发生变化的有10万左右

## 数仓建设方法总结

### 第一步：分析出需求的==维度与度量==

> 一般都是多维多度量分析：例如统计某些维度下，多个度量的计算

- 维度数据：确定维度数据在哪里，如何计算产生。在复杂的业务中，一般需要多表join产生。
- 度量数据：确定度量数据在哪里，用户产生。一般在事实表中可以找到。



### 第二步：维度建模/设计表

> 最重要，相对复杂：因为此处需要考虑长久，日后新增数据要更方便的处理
>
> 业务复杂度  约等于  维度建模复杂度

- 结果表设计：最后结果存放形式，有哪些字段
- 维度表设计：根据需求确定，一般(变化)维度表需要==拉链==操作
- 事实表设计：根据需求确定，周期事实表需要==拉链==操作



### 第三步：度量计算（指标计算）

> 维度建模做的好，此处相对容易

- 事实表与维度表进行JOIN,得出结果数据
- 结果数据存入结果表